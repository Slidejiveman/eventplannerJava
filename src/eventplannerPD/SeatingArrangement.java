package eventplannerPD;

import java.io.Serializable;
import java.util.Collection;
import java.util.TreeMap;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.Transient;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;

import com.owlike.genson.annotation.JsonIgnore;

/**
 * The seating arrangement is a EventTable of guests assigned to tables at the event. 
 * The guests at the tables should only be those who they are required to set 
 * with or who they are indifferent about. A guest should never be seated at a 
 * EventTable with another guest they should avoid.
 * 
 * The primary reports generated by this system are based on the seating arrangements of the guests. 
 * One report will show the guest EventTable assignments alphabetically and another will show them by EventTable number.
 */

// This should probably hold some kind of map of Guests to Tables
// Or, this can hold the collection of Tables that are currently in Event
// with guests assigned to those tables.
// I'll leave it up to Augustin as he solves that problem.
@XmlRootElement(name = "seatingarrangement")
@Entity(name = "seatingarrangement")
public class SeatingArrangement implements Serializable {

    /**
	 * Allows Serialization so that the item may be stored in the
	 * database
	 */
	private static final long serialVersionUID = 1628049267895624425L;
	/**
     * The  unique identifier for a seating arrangement. 
     * These will be used to ensure that the database provides a 
     * unique row in the seating arrangement EventTable for each arrangement.
     */
	@Id
	@Column(name = "seatingarrangement_id", updatable = false, nullable = false)
	@GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;
    /**
     * The event the seating arrangement is associated with.
     */
	@JsonIgnore
    @OneToOne(cascade = CascadeType.ALL, orphanRemoval = true, optional=true,mappedBy="seatingAssigment")
    @JoinColumn(name = "seatingarrangement_event", nullable = false)
    private Event event;
    
    /**
     * The collection of tables at the with the seating assignments updated 
     * for a given event. 
     * Each EventTable knows its size and shape. 
     * Seat numbers begin from the leftmost upper corner of rectangular 
     * tables or the twelve o'clock position of elliptical tables.
     */
	@JsonIgnore
    @OneToMany(targetEntity = EventTable.class, cascade = CascadeType.ALL, mappedBy = "seatingArrangement",orphanRemoval=true)
    @JoinColumn(name = "seatingarrangement_tables", nullable = true)
    private Collection<EventTable> tables;
	
	@Transient
	@JsonIgnore
	private TreeMap<Guest,EventTable> seatingAssignments;
	
	@Transient
	@JsonIgnore
	private Integer arrangementScore;
	
    @JsonIgnore
    public Collection<EventTable> getTables() {
		return tables;
	}
    @JsonIgnore
    @XmlTransient
	public void setTables(Collection<EventTable> tables) {
		this.tables = tables;
	}

	public int getId() {
        return this.id;
    }

	@XmlElement
    public void setId(int id) {
        this.id = id;
    }
	@JsonIgnore
    public Event getEvent() {
        return this.event;
    }
	@JsonIgnore
    @XmlTransient
    public void setEvent(Event event) {
        this.event = event;
    }

    /**
     * The default constructor for a seating arrangement. 
     * This is required for JPA persistence.
     */
    public SeatingArrangement() {
        // Needed if this is persisted.
    }
    public SeatingArrangement(Integer score) {
        this.setArrangementScore(score);
        this.seatingAssignments= new TreeMap<Guest,EventTable>();
    }
    
    /**
     * The seating arrangement may be deleted if the event is in the Open or Canceled state. 
     * Otherwise, the seating arrangement is under review or has been approved. It cannot be deleted after that.
     * @return True: It is okay to delete the seating arrangement.
     *         False: It is not okay to delete the seating arrangement.
     */
    public boolean isOkToDelete() {
        // TODO - implement SeatingArrangement.isOkToDelete
        return true;
    }

    /**
     * Sorts the guests with their seats by guest name alphabetically.
     * This output can then be printed using iTxtPDF.
     */
    public void sortAlphabetically() {
        // TODO - implement SeatingArrangement.sortAlphabetically
        
    }

    /**
     * Sorts the seating arrangement by EventTable number. 
     * The result can then be printed with iTxtPDF.
     */
    public void sortByTableNumber() {
        //test GIT
    }
    @JsonIgnore
    @XmlTransient
    public TreeMap<Guest,EventTable>getSeatingAssignments(){
    	return this.seatingAssignments;
    }
    @JsonIgnore
	public void setArrangementScore(int score) {
		this.arrangementScore= score;
		
	}
	@JsonIgnore
    @XmlTransient
	public Integer getArrangementScore(){
		return this.arrangementScore;
	}

}