package eventplannerPD;

import java.io.Serializable;
import java.util.Collection;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.PrimaryKeyJoinColumn;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

/**
 * The seating arrangement is a table of guests assigned to tables at the event. 
 * The guests at the tables should only be those who they are required to set 
 * with or who they are indifferent about. A guest should never be seated at a 
 * table with another guest they should avoid.
 * 
 * The primary reports generated by this system are based on the seating arrangements of the guests. 
 * One report will show the guest table assignments alphabetically and another will show them by table number.
 */

// This should probably hold some kind of map of Guests to Tables
// Or, this can hold the collection of Tables that are currently in Event
// with guests assigned to those tables.
// I'll leave it up to Augustin as he solves that problem.
@XmlRootElement(name = "seatingarrangement")
@Entity(name = "seatingarrangement")
public class SeatingArrangement implements Serializable {

    /**
	 * Allows Serialization so that the item may be stored in the
	 * database
	 */
	private static final long serialVersionUID = 1628049267895624425L;
	/**
     * The  unique identifier for a seating arrangement. 
     * These will be used to ensure that the database provides a 
     * unique row in the seating arrangement table for each arrangement.
     */
	@Id
	@Column(name = "seatingarrangement_id", updatable = false, nullable = false)
	//@GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;
    /**
     * The event the seating arrangement is associated with.
     */
    @OneToOne(mappedBy="seatingAssigment")
    @JoinColumn(name = "seatingarrangement_event", nullable = false)
    private Event event;
    
    /**
     * The collection of tables at the with the seating assignments updated 
     * for a given event. 
     * Each table knows its size and shape. 
     * Seat numbers begin from the leftmost upper corner of rectangular 
     * tables or the twelve o'clock position of elliptical tables.
     */
    @OneToMany(targetEntity = Table.class, mappedBy = "seatingArrangement")
    @JoinColumn(name = "seatingarrangement_tables", nullable = true)
    private Collection<Table> tables;

    public Collection<Table> getTables() {
		return tables;
	}

	public void setTables(Collection<Table> tables) {
		this.tables = tables;
	}

	public int getId() {
        return this.id;
    }

	@XmlElement
    public void setId(int id) {
        this.id = id;
    }

    public Event getEvent() {
        return this.event;
    }

    public void setEvent(Event event) {
        this.event = event;
    }

    /**
     * The default constructor for a seating arrangement. 
     * This is required for JPA persistence.
     */
    public SeatingArrangement() {
        // Needed if this is persisted.
    }

    /**
     * The seating arrangement may be deleted if the event is in the Open or Canceled state. 
     * Otherwise, the seating arrangement is under review or has been approved. It cannot be deleted after that.
     * @return True: It is okay to delete the seating arrangement.
     *         False: It is not okay to delete the seating arrangement.
     */
    public boolean isOkToDelete() {
        // TODO - implement SeatingArrangement.isOkToDelete
        throw new UnsupportedOperationException();
    }

    /**
     * Sorts the guests with their seats by guest name alphabetically.
     * This output can then be printed using iTxtPDF.
     */
    public void sortAlphabetically() {
        // TODO - implement SeatingArrangement.sortAlphabetically
        throw new UnsupportedOperationException();
    }

    /**
     * Sorts the seating arrangement by table number. 
     * The result can then be printed with iTxtPDF.
     */
    public void sortByTableNumber() {
        //test GIT
    }

}